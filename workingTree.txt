//Nicholas Righi
//CSE 143 -- AK
//6/6/2019
//Homework 8 -- Cynthia Li 
//Contructs a HuffmanTree to compress and uncompress text files. 

import java.io.PrintStream;
import java.util.*;

public class HuffmanTree {

    private HuffmanNode root;

    //pre: an int array of character frequencies to construct a huffman tree from, where the index
    //      of the array corresponds to the character and the value at that index the frequency
    //post: constructs a huffman tree from the passed array
    public HuffmanTree(int[] count) {

        Queue<HuffmanNode> priorityQueue = new PriorityQueue<HuffmanNode>();

        for (int i = 0; i < count.length; i++) {

            if (count[i] > 0) {

                priorityQueue.add(new HuffmanNode(i, count[i]));

            }

        }

        //add end of file character to priority queue
        priorityQueue.add(new HuffmanNode(count.length, 1));

        constructTree(priorityQueue);
        root = priorityQueue.peek();

    }

    //pre: an open PrintStream to write to
    //post: writes the current huffman tree to the passed PrintStream in traversal order. Includes 
    //      a pseduo eof character
    public void write(PrintStream output) {

        writeHelper(output, root, "");

    }

    //pre: a PrintStream to write to, a HuffmanNode to examine, and a character code to add to 
    //post: prints all character values and associated codes to the specifed output in standard
    //      travseral order
    private void writeHelper(PrintStream output, HuffmanNode root, String characterCode) {

        if (!isLeaf(root)) {

            writeHelper(output, root.left, characterCode + 0);
            writeHelper(output, root.right, characterCode + 1);

        } else {

            output.println(root.character);
            output.println(characterCode);

        }

    }

    //pre: a Scanner linked to a file containint a huffman tree in standard format
    //post: constructs a HuffmanTree from the scanner input
    public HuffmanTree(Scanner input) {

        while (input.hasNextLine()) {

            int character = Integer.parseInt((input.nextLine()));
            String code = input.nextLine();

            this.root = HuffmanTreeHelper(code, this.root, character);

        }

    }

    //pre: a string code to use to traverse the tree, a HuffmanNode to add to, and an ASCII 
    //      character to add
    //post: writes the passed ASCII character to the node specified by the code
    private HuffmanNode HuffmanTreeHelper(String code, HuffmanNode root, int character) {

        if (code.isEmpty()) {

            return new HuffmanNode(character, -1, null, null);

        } else if (root == null) {

            root = new HuffmanNode(-1, -1, null, null);

        }

        if (code.charAt(0) == '0') {

            root.left = HuffmanTreeHelper(code.substring(1), root.left, character);

        } else {

            root.right = HuffmanTreeHelper(code.substring(1), root.right, character);

        }

        return root;

    }

    //pre: a BitInputStream to read from, a PrintStream to write to, an int that specifies the 
    //     end of the file
    //post: reads bits from the input and writes the corresponding characters to the output.
    //      Stops once it encounters the specified end of file character
    public void decode(BitInputStream input, PrintStream output, int eof) {

        boolean write = true;
        HuffmanNode temp = this.root;

        while (write) {

            if (isLeaf(temp)) {

                if (temp.character != eof) {

                    output.write(temp.character);
                    temp = this.root;

                } else {

                    write = false;

                }
            } else {

                int bit = input.readBit();

                if (bit == 0) {

                    temp = temp.left;

                } else {

                    temp = temp.right;

                }

            }

        }

    }

    //post: constructs a HuffmanTree from the priority queue
    private void constructTree(Queue<HuffmanNode> priorityQueue) {

        while (priorityQueue.size() > 1) {

            HuffmanNode first = priorityQueue.poll();
            HuffmanNode second = priorityQueue.poll();

            HuffmanNode newNode = new HuffmanNode(-1, first.frequency + second.frequency,
                    first, second);

            priorityQueue.add(newNode);
        }

    }

    //pre: a non null HuffmanNode
    //post: returns true if the HuffmanNode is a leaf, otherwise false
    private boolean isLeaf(HuffmanNode root) {

        return root.left == null && root.right == null;

    }

}
